export default (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u){return {data:{"page-data":{_path:"\u002Farticles\u002Funit-testing-micropython-with-mocks",_dir:"articles",_draft:f,_partial:f,_locale:"en",_empty:f,title:"Unit Testing in MicroPython with Mocks",description:i,excerpt:{type:m,children:[{type:b,tag:d,props:{},children:[{type:a,value:i}]}]},date:"2020-02-07",draft:f,tags:["micropython","testing","mocks","tutorial"],categories:[g,"embedded"],body:{type:m,children:[{type:b,tag:d,props:{},children:[{type:a,value:i}]},{type:b,tag:n,props:{id:"mocking"},children:[{type:a,value:"Mocking"}]},{type:b,tag:d,props:{},children:[{type:a,value:"Mocks allow us to replace the hardware interfacing functionality under-the-hood\nwith predefined results and side-effects. For example, if there is a piece of\nlogic that retrieves values from an accelerometer to get a device's\norientation, it would be possible to mock the returned values of the\naccelerometer -- allowing us to run the unit tests on a device that does not\nhave an accelerometer sensor installed."}]},{type:b,tag:n,props:{id:"a-micropython-mocking-example"},children:[{type:a,value:"A MicroPython Mocking Example"}]},{type:b,tag:d,props:{},children:[{type:a,value:"In this example, we will be unit testing a module named "},{type:b,tag:c,props:{},children:[{type:a,value:o}]},{type:a,value:", that\ndepends on the MicroPython library "},{type:b,tag:c,props:{},children:[{type:a,value:j}]},{type:a,value:" to log the most recent Epoch time to\na file."}]},{type:b,tag:e,props:{code:p,language:g},children:[{type:b,tag:k,props:{},children:[{type:b,tag:e,props:{__ignoreMap:h},children:[{type:a,value:p}]}]}]},{type:b,tag:d,props:{},children:[{type:a,value:"First, because the "},{type:b,tag:c,props:{},children:[{type:a,value:j}]},{type:a,value:" module is not installed on the machine that the unit\ntests on, we must mock "},{type:b,tag:c,props:{},children:[{type:a,value:j}]},{type:a,value:" module before importing "},{type:b,tag:c,props:{},children:[{type:a,value:o}]},{type:a,value:" in our\nunit test file."}]},{type:b,tag:e,props:{code:q,language:g},children:[{type:b,tag:k,props:{},children:[{type:b,tag:e,props:{__ignoreMap:h},children:[{type:a,value:q}]}]}]},{type:b,tag:d,props:{},children:[{type:a,value:"Then, we can write a test that patches the "},{type:b,tag:c,props:{},children:[{type:a,value:"utime.time"}]},{type:a,value:" functionality so that\nit returns a value of our choosing -- in this case, "},{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:"."}]},{type:b,tag:e,props:{code:s,language:g},children:[{type:b,tag:k,props:{},children:[{type:b,tag:e,props:{__ignoreMap:h},children:[{type:a,value:s}]}]}]},{type:b,tag:d,props:{},children:[{type:a,value:"Now, when the "},{type:b,tag:c,props:{},children:[{type:a,value:"save_time"}]},{type:a,value:" method gets the latest time from "},{type:b,tag:c,props:{},children:[{type:a,value:"utime.time()"}]},{type:a,value:", the\nvalue will be patched to return "},{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:". That value will be written to a file,\nand our unit test will pass!"}]},{type:b,tag:"h2",props:{id:t},children:[{type:a,value:u}]},{type:b,tag:"ol",props:{},children:[{type:b,tag:"li",props:{},children:[{type:b,tag:"a",props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Flibrary\u002Funittest.html",rel:["nofollow"]},children:[{type:b,tag:c,props:{},children:[{type:a,value:"unittest"}]},{type:a,value:" â€” Unit testing framework"}]}]}]}],toc:{title:h,searchDepth:l,depth:l,links:[{id:t,depth:l,text:u}]}},_type:"markdown",_id:"content:articles:unit-testing-micropython-with-mocks.md",_source:"content",_file:"articles\u002Funit-testing-micropython-with-mocks.md",_extension:"md"}},prerenderedAt:1672496695072}}("text","element","code-inline","p","code",false,"python","","Unit testing code for embedded systems can be challenging. While it's possible\nto leverage emulators, write side-effect free code, or run tests on the\nhardware itself, it's often easiest to unit test the code on your personal\ncomputer with mocked hardware functionality.","utime","pre",2,"root","h1","time_logger","# time_logger.py\n\nclass TimeLogger(object):\n\n    def save_time(self):\n        \"\"\" Overwrite a file with the most recent Epoch timestamp from `utime`\n        \"\"\"\n        with open(\"LAST_KNOWN_TIME\", \"w+\") as f:\n            f.write(str(utime.time()))\n","# test_time_logger.py\n\nimport unittest\n\nfrom unittest.mock import MagicMock\n\nsys.modules['utime'] = MagicMock()\nfrom time_logger import TimeLogger\n","1234","class TestTimeLogger(unittest.TestCase):\n\n    def test_save_time(self):\n        \"\"\" Verify that the Epoch time is written to file\n        \"\"\"\n        with unittest.mock.patch(\"utime.time\", return_value=1234):\n            t = TimeLogger()\n            t.save_time()\n            with open(\"LAST_KNOWN_TIME\") as f:\n                self.assertEqual(\"1234\", f.read())\n","references","References"))